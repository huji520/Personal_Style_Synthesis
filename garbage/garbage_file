    in File.py:
    # def active_time(self):
    #     """
    #     :return: total active time (without pauses time)
    #     """
    #     time = 0.0
    #     for stroke in self._data:
    #         if not stroke.is_pause():
    #             time += stroke.total_time()
    #
    #     return time


    in Analyzer.py:
    # @staticmethod
    # def get_file2(data):
    #     strokes_list = []
    #     stroke = dict()
    #     counter = 0
    #     number_of_seq_pauses = 0
    #
    #     for i, time in enumerate(data['time']):
    #         if time == 'Pause':
    #             # deal with pause sequences of two or more
    #             if data['time'][i+1] == 'Pause':
    #                 number_of_seq_pauses += 1
    #                 counter = i + 1
    #                 continue
    #
    #             for column in data:
    #                 stroke[column] = data[column][counter:i]
    #             counter = i + 1
    #             strokes_list.append(Stroke(stroke))
    #             stroke = dict()
    #             if i + 2 == len(data['time']):  # end of file
    #                 break
    #
    #             # create pause-stroke
    #             pause = [list(data['time'])[i-1 - number_of_seq_pauses], list(data['time'])[i+1]]
    #             strokes_list.append(Stroke(pause, pause=True))
    #             number_of_seq_pauses = 0
    #
    #     return File(strokes_list)


    # class Analyzer:
#     MIN_SIZE_OF_STROKE = 2
#     TIME_STAMP = 0.017
#
#     @staticmethod
#     def get_data_file(path):
#         """
#         :param path: string
#         :return: DataFrame object
#         """
#         return pd.read_csv(path, delimiter='\t')
#
#     @staticmethod
#     def get_strokes(data):
#         """
#         :param data: DataFrame object
#         :return: list of strokes that represent the data
#         """
#         stroke_list = []
#         stroke = dict()
#         start_stroke_location = 0  # the location of the next stroke in data
#         current_time = 0.0
#
#         for i, time in enumerate(data['time']):
#             if time == 'Pause':
#                 if i - start_stroke_location < Analyzer.MIN_SIZE_OF_STROKE:  # MIN_SIZE_OF_STROKE = 2
#                     start_stroke_location = i + 1
#                     continue
#
#                 for feature in data:
#                     stroke[feature] = data[feature][start_stroke_location:i]
#                     if feature == 'time':
#                         for j in range(start_stroke_location, i):
#                             stroke['time'][j] = current_time
#                             current_time += Analyzer.TIME_STAMP  # TIME_STAMP = 0.017
#
#                 start_stroke_location = i + 1
#                 stroke_list.append(Stroke(stroke))
#                 stroke = dict()
#
#         return stroke_list
#
#     @staticmethod
#     def get_ref_path(data):
#         """
#         :param data: DataFrame object
#         :return: path to reference picture
#         """
#         ref_name = data['time'][len(data['time'])-1].split(' ')[1]
#         return "ref_pics/" + ref_name + ".JPG"
#
#     @staticmethod
#     def get_pic_path(path):
#         ref_folder = path.split('/')[1]
#         participant_name = path.split('/')[2]
#         for file in os.listdir("data/" + ref_folder + "/" + participant_name):
#             if "DS_Store" not in file:
#                 if file.endswith(".png"):
#                     return "data/" + ref_folder + "/" + participant_name + "/" + file
#
#     @staticmethod
#     def create_drawing(path):
#         data = Analyzer.get_data_file(path)
#         pic_path = Analyzer.get_pic_path(path)
#         ref_path = Analyzer.get_ref_path(data)
#         if pic_path is not None and ref_path is not None:
#             return Drawing(Analyzer.get_strokes(data), pic_path, ref_path)



# class Drawing:
#     def __init__(self, data, pic_path, ref_path):
#         """
#         :param data: list of Strokes objects
#         """
#         self._data = data
#         self._ref_path = ref_path
#         self._pic_path = pic_path
#
#     def get_ref_path(self):
#         return self._ref_path
#
#     def get_pic_path(self):
#         return self._pic_path
#
#     def get_data(self):
#         """
#         :return: list of Stroke objects
#         """
#         return self._data
#
#     def size(self):
#         """
#         :return: number of stroke in the file
#         """
#         return len(self._data)
#
#     def total_length(self):
#         """
#         :return: first value is the total geometric length of a file (unit -> pixel),
#                  second value is array of all the strokes lengths
#         """
#         dist = 0.0
#         arr = []
#         for stroke in self._data:
#             arr.append(stroke.total_length())
#             dist += stroke.total_length()
#
#         return dist, np.asarray(arr)
#
#     def average_length_of_stroke(self):
#         """
#         :return: average of geometric length of a single stroke
#         """
#         return self.total_length()[0] / float(self.size())
#
#     def length_std(self):
#         """
#         :return: std of the geometric length of the strokes
#         """
#         return self.total_length()[1].std()
#
#     def active_time(self):
#         """
#         :return: total active time (without pauses time)
#         """
#         return self._data[-1].time()[-1]
#
#     def get_strokes_as_one(self):
#         """
#         @TODO - this is not efficient implements
#         :return: all the strokes in the file, merged into one stroke, without pauses
#         """
#         stroke_list = []
#         for stroke in self._data:
#             stroke_list.append(stroke.get_data())
#
#         stroke_list_copy = copy.deepcopy(stroke_list)
#         for stroke in stroke_list_copy:
#             for feature in stroke.keys():
#                 stroke[feature] = list(stroke[feature])
#
#         for key, value in stroke_list_copy[0].items():
#             for i in range(1, len(stroke_list_copy)):
#                 value.extend(stroke_list_copy[i][key])
#         return Stroke(stroke_list_copy[0])
#
#     def speed_vs_time(self):
#         """
#         plot graph of speed vs time
#         """
#         time = []
#         speed = []
#         for stroke in self.get_data():
#             time.append(stroke.time()[0])
#             speed.append(stroke.average_speed())
#
#         time = np.asarray(time)
#         speed = np.asarray(speed)
#         plt.scatter(time, speed, s=2)
#         plt.title("speed mean is: " + str(speed.mean()) + "\nspeed std is: " + str(speed.std()))
#         plt.xlabel('time [sec]')
#         plt.ylabel('speed [pixel/sec]')
#         plt.show()
#
#     def pressure_vs_time(self):
#         """
#         plot graph of speed vs time
#         """
#         time = []
#         pressure = []
#         for stroke in self.get_data():
#             time.append(stroke.time()[0])
#             pressure.append(stroke.average_pressure())
#
#         time = np.asarray(time)
#         pressure = np.asarray(pressure)
#         plt.scatter(time, pressure, s=2)
#         plt.title("pressure mean is: " + str(pressure.mean()) + "\npressure std is: " + str(pressure.std()))
#         plt.xlabel('time [sec]')
#         plt.ylabel('pressure [?]')
#         plt.show()
#
#     def length_vs_time(self):
#         """
#         plot graph of speed vs time
#         """
#         time = []
#         length = []
#         for stroke in self.get_data():
#             time.append(stroke.time()[0])
#             length.append(stroke.total_length())
#
#         time = np.asarray(time)
#         length = np.asarray(length)
#         plt.scatter(time, length, s=2)
#         plt.title("length mean is: " + str(length.mean()) + "\nlength std is: " + str(length.std()))
#         plt.xlabel('time [sec]')
#         plt.ylabel('length [pixel]')
#         plt.show()
#
#     def plot_picture(self):
#         """
#         @TODO - rotate
#         """
#         # one_stroke = self.get_strokes_as_one()
#         #
#         # plt.subplot(1, 3, 1)
#         # plt.scatter(one_stroke.x(), one_stroke.y(), s=0.5,)
#         if self._ref_path == "ref_pics/D12":
#             return
#
#         plt.subplot(1, 2, 1)
#         plt.imshow(mpimg.imread(self._pic_path))
#
#         plt.subplot(1, 2, 2)
#         plt.imshow(mpimg.imread(self._ref_path))
#
#         plt.show()




# class Stroke:
#     def __init__(self, data):
#         """
#         :param data: dictionary. keys are the features (time, x, y ,...) and their values.
#         """
#         self._data = data
#
#     def get_data(self):
#         """
#         :return: dictionary. keys are the features (time, x, y ,...) and their values.
#         """
#         return self._data
#
#     def size(self):
#         """
#         :return: number of stamps in a stroke
#         """
#         return len(self._data['time'])
#
#     def time(self):
#         """
#         :return: numpy array of time values of the stroke
#         """
#         return self._string2float_array(self._data['time'])
#
#     def x(self):
#         """
#         :return: numpy array of x values of the stroke, in case of pause-stroke, fill -1
#         """
#         return self._string2float_array(self._data['x'])
#
#     def y(self):
#         """
#         :return: numpy array of y values of the stroke, in case of pause-stroke, fill -1
#         """
#         return self._string2float_array(self._data['y'])
#
#     def pressure(self):
#         """
#         :return: numpy array of pressure values of the stroke, in case of pause-stroke, fill 0
#         """
#         return self._string2float_array(self._data['pressure'])
#
#     def tiltX(self):
#         """
#         :return: numpy array of tiltX values of the stroke, in case of pause-stroke, fill -1
#         """
#         return self._string2float_array(self._data['tiltX'])
#
#     def tiltY(self):
#         """
#         :return: numpy array of tiltY values of the stroke, in case of pause-stroke, fill -1
#         """
#         return self._string2float_array(self._data['tiltY'])
#
#     def azimuth(self):
#         """
#         :return: numpy array of azimuth values of the stroke, in case of pause-stroke, fill -1
#         """
#         return self._string2float_array(self._data['azimuth'])
#
#     def sidePressure(self):
#         """
#         :return: numpy array of sidePressure values of the stroke, in case of pause-stroke, fill -1
#         """
#         return self._string2float_array(self._data['sidePressure'])
#
#     def rotation(self):
#         """
#         :return: numpy array of rotation values of the stroke, in case of pause-stroke, fill -1
#         """
#         return self._string2float_array(self._data['rotation'])
#
#     def total_length(self):
#         """
#         :return: the total geometric length of a stroke (unit -> pixel)
#         """
#         x_array = self.x()
#         y_array = self.y()
#         dist = 0.0
#         for i in range(1, len(x_array)):
#             dist += self.calc_dist_2D(x_array[i - 1], x_array[i], y_array[i - 1], y_array[i])
#
#         return dist
#
#     def total_time(self):
#         """
#         :return: the total time of a stroke
#         """
#         time_array = self.time()
#         time = 0.0
#         for i in range(1, len(time_array)):
#             time += (time_array[i] - time_array[i-1])
#
#         return time
#
#     def average_speed(self):
#         """
#         :return: the average speed of a stroke
#         """
#         return self.total_length() / self.total_time()
#
#     def average_pressure(self):
#         """
#         :return: average pressure of the stroke
#         """
#         return self.pressure().mean()
#
#     def average_tiltX(self):
#         """
#         :return: average tiltX of the stroke
#         """
#         return self.tiltX().mean()
#
#     def average_tiltY(self):
#         """
#         :return: average tiltY of the stroke
#         """
#         return self.tiltY().mean()
#
#     def average_azimuth(self):
#         """
#         :return: average azimuth of the stroke
#         """
#         return self.azimuth().mean()
#
#     def average_sidePressure(self):
#         """
#         :return: average sidePressure of the stroke
#         """
#         return self.sidePressure().mean()
#
#     def average_rotation(self):
#         """
#         :return: average rotation of the stroke
#         """
#         return self.rotation().mean()
#
#     @staticmethod
#     def calc_dist_2D(old_x, new_x, old_y, new_y):
#         """
#         :return: the distance between two points - 2D
#         """
#         return math.sqrt(float(pow(new_x - old_x, 2)) + float(pow(new_y - old_y, 2)))
#
#     @staticmethod
#     def _string2float_array(string_array):
#         """
#         :param string_array: array with numbers represents by strings
#         :return: numpy array with float values instead of strings
#         """
#         array = []
#         for value in string_array:
#             array.append(float(value))
#         return np.asarray(array)